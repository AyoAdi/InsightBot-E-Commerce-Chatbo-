# -*- coding: utf-8 -*-
"""run_agent.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qLVp9WhNJj4SQkW2GaZrAnqsp32RQwmM
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile run_agent.py
# # The above line is to add the file to the temporary storage directiry of the google collab environment
# 
# import subprocess
# import sys
# 
# def install_packages():
#     print("Installing/Upgrading necessary Python packages...")
#     try:
#         subprocess.check_call([sys.executable, "-m", "pip", "install", "-U", "google-generativeai", "pandas", "matplotlib"])
#         print("Packages installed successfully.")
#     except subprocess.CalledProcessError as e:
#         print(f"Error installing packages: {e}")
#         sys.exit(1)
# 
# install_packages()
# 
# import pandas as pd
# import sqlite3
# import google.generativeai as genai
# import os
# import time
# import matplotlib.pyplot as plt
# 
# print("Libraries imported.")
# 
# db_file_path = 'ecommerce_data.db'
# print(f"Database will be stored temporarily at: {db_file_path}")
# 
# conn = sqlite3.connect(db_file_path)
# cursor = conn.cursor()
# print("Connected to SQLite database.")
# 
# 
# create_eligibility_sql = """
# CREATE TABLE IF NOT EXISTS product_level_eligibility_table (
#     item_id INTEGER NOT NULL,
#     eligibility_datetime_utc DATETIME NOT NULL,
#     eligibility BOOLEAN,
#     message TEXT,
#     PRIMARY KEY (item_id, eligibility_datetime_utc)
# );
# """
# cursor.execute(create_eligibility_sql)
# print("Table 'product_level_eligibility_table' created or already exists.")
# 
# create_ad_sales_sql = """
# CREATE TABLE IF NOT EXISTS product_level_ad_sales_metrics (
#     date DATE NOT NULL,
#     item_id INTEGER NOT NULL,
#     ad_sales REAL,
#     impressions INTEGER,
#     ad_spend REAL,
#     clicks INTEGER,
#     units_sold INTEGER,
#     PRIMARY KEY (date, item_id)
# );
# """
# cursor.execute(create_ad_sales_sql)
# print("Table 'product_level_ad_sales_metrics' created or already exists.")
# 
# create_total_sales_sql = """
# CREATE TABLE IF NOT EXISTS product_level_total_sales_metrics (
#     date DATE NOT NULL,
#     item_id INTEGER NOT NULL,
#     total_sales REAL,
#     total_units_ordered INTEGER,
#     PRIMARY KEY (date, item_id)
# );
# """
# cursor.execute(create_total_sales_sql)
# print("Table 'product_level_total_sales_metrics' created or already exists.")
# 
# conn.commit()
# print("All table schemas committed to the database.")
# 
# eligibility_url = 'https://raw.githubusercontent.com/AyoAdi/Sales_chatbot/refs/heads/main/Datasets/Improved%20Datasets/product_level_eligibility_table_improved.csv'
# ad_sales_url = 'https://raw.githubusercontent.com/AyoAdi/Sales_chatbot/refs/heads/main/Datasets/Improved%20Datasets/product_level_sales_and_metrics_improved.csv'
# total_sales_url = 'https://raw.githubusercontent.com/AyoAdi/Sales_chatbot/refs/heads/main/Datasets/Improved%20Datasets/product_level_total_sales_and_metrics_improved.csv'
# 
# print("\nLoading cleaned DataFrames from GitHub URLs...")
# 
# df_eligibility = pd.read_csv(eligibility_url)
# df_eligibility['eligibility_datetime_utc'] = pd.to_datetime(df_eligibility['eligibility_datetime_utc'])
# df_eligibility['eligibility'] = df_eligibility['eligibility'].astype(int)
# 
# df_ad_sales = pd.read_csv(ad_sales_url)
# df_ad_sales['date'] = pd.to_datetime(df_ad_sales['date'])
# 
# df_total_sales = pd.read_csv(total_sales_url)
# df_total_sales['date'] = pd.to_datetime(df_total_sales['date'])
# 
# print("DataFrames loaded and prepped.")
# print("Loading data into SQL tables...")
# 
# df_eligibility.to_sql( 'product_level_eligibility_table', conn, if_exists='replace', index=False)
# print("Data loaded into 'product_level_eligibility_table'.")
# 
# df_ad_sales.to_sql( 'product_level_ad_sales_metrics', conn, if_exists='replace', index=False)
# print("Data loaded into 'product_level_ad_sales_metrics'.")
# 
# df_total_sales.to_sql( 'product_level_total_sales_metrics', conn, if_exists='replace', index=False)
# print("Data loaded into 'product_level_total_sales_metrics'.")
# 
# conn.commit()
# print("All data committed to the database.")
# 
# 
# print("\nConfiguring Gemini Flash LLM...")
# GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
# if GOOGLE_API_KEY:
#     genai.configure(api_key=GOOGLE_API_KEY)
#     print("Gemini API key loaded from environment variable and configured.")
# else:
#     print("ERROR: GOOGLE_API_KEY environment variable not found.")
#     print("Please set the GOOGLE_API_KEY environment variable in the terminal before running this script.")
#     sys.exit(1)
# 
# gemini_model = genai.GenerativeModel('models/gemini-2.5-flash')
# print("Gemini Flash model initialized.")
# 
# def get_table_schema(cursor):
#     """Fetches the schema of all tables in the SQLite database."""
#     cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
#     tables = cursor.fetchall()
#     schema_info = {}
#     for table_name_tuple in tables:
#         table_name = table_name_tuple[0]
#         cursor.execute(f"PRAGMA table_info({table_name});")
#         columns = cursor.fetchall()
#         column_details = []
#         for col in columns:
#             cid, name, ctype, notnull, dflt_value, pk = col
#             column_details.append(f"{name} {ctype} {'NOT NULL' if notnull else ''} {'PRIMARY KEY' if pk else ''}")
#         schema_info[table_name] = ", ".join(column_details)
#     return schema_info
# 
# def ask_llm_for_sql(question: str, schema: dict, gemini_model) -> str:
#     """
#     Asks the Gemini LLM to convert a natural language question into an SQL query.
#     The LLM should indicate if a plot is requested by adding '##PLOT##' at the end.
#     """
#     schema_str = "\n".join([f"Table: {table}\nColumns: {cols}" for table, cols in schema.items()])
# 
#     prompt_parts = [
#         "You are an expert SQL query generator. Your sole purpose is to convert user questions into precise and accurate SQL queries.",
#         "You must use the provided database schema to identify the correct tables and columns.",
#         "Strictly adhere to the schema provided below.",
#         "",
#         "Here is the database schema:",
#         schema_str,
#         "",
#         "**Important Rules for SQL Generation:**",
#         "-   **Always select the correct table(s) based on the question's context.**",
#         "    -   'total sales', 'units ordered' -> use `product_level_total_sales_metrics`",
#         "    -   'ad sales', 'impressions', 'ad spend', 'clicks', 'units sold from ads', 'CPC', 'RoAS' -> use `product_level_ad_sales_metrics`",
#         "    -   'eligible products', 'eligibility status' -> use `product_level_eligibility_table`",
#         "-   Use appropriate SQL aggregate functions (SUM, AVG, MAX, MIN, COUNT) for questions involving totals, averages, highest/lowest, or counts.",
#         "-   Use JOINs only when necessary to combine data from different tables based on common columns (like item_id or date).",
#         "-   Filter data using WHERE clauses (e.g., for specific dates, item_ids, or eligibility status).",
#         "-   When asked for 'Which product...' or 'Top X products...', use `GROUP BY item_id` with `ORDER BY` and `LIMIT`.",
#         "-   Ensure column names and table names exactly match the schema.",
#         "-   For RoAS, use `SUM(ad_sales) * 1.0 / SUM(ad_spend)` to ensure float division.",
#         "-   For CPC, use `SUM(ad_spend) * 1.0 / SUM(clicks)` to ensure float division.",
#         "-   If the user asks to 'plot', 'graph', 'chart', or 'visualize' data, append the string '##PLOT##' to the end of the SQL query. The query for plotting should return at least two columns (e.g., a category and a value).",
#         "-   **Output Format: STRICTLY ONLY THE SQL QUERY, optionally followed by '##PLOT##'. DO NOT include any markdown code blocks (e.g., ```sql ```), introductory text, explanations, or concluding remarks.**",
#         "",
#         "Examples:",
#         "User Question: What is my total sales?",
#         "SQL Query: SELECT SUM(total_sales) FROM product_level_total_sales_metrics;",
#         "",
#         "User Question: Calculate the RoAS (Return on Ad Spend).",
#         "SQL Query: SELECT SUM(ad_sales) * 1.0 / SUM(ad_spend) FROM product_level_ad_sales_metrics;",
#         "",
#         "User Question: Which product had the highest CPC (Cost Per Click)?",
#         "SQL Query: SELECT item_id, SUM(ad_spend) * 1.0 / SUM(clicks) AS cpc FROM product_level_ad_sales_metrics GROUP BY item_id ORDER BY cpc DESC LIMIT 1;",
#         "",
#         "User Question: Plot total sales by date.",
#         "SQL Query: SELECT date, SUM(total_sales) FROM product_level_total_sales_metrics GROUP BY date ORDER BY date;##PLOT##",
#         "",
#         "User Question: Graph ad spend by item.",
#         "SQL Query: SELECT item_id, SUM(ad_spend) FROM product_level_ad_sales_metrics GROUP BY item_id ORDER BY SUM(ad_spend) DESC LIMIT 10;##PLOT##",
#         "",
#         f"User Question: {question}",
#         "SQL Query:"
#     ]
# 
#     full_generated_sql_text = ""
#     try:
#         response = gemini_model.generate_content("\n".join(prompt_parts))
#         full_generated_sql_text = response.text.strip()
# 
#         generated_text = full_generated_sql_text.strip()
# 
#         if generated_text.lower().startswith("```sql"):
#             generated_text = generated_text[len("```sql"):].strip()
#         if generated_text.endswith("```"):
#             generated_text = generated_text[:-len("```")].strip()
#         if generated_text.startswith("```"):
#             generated_text = generated_text[len("```"):].strip()
# 
#         plot_intent = False
#         if "##PLOT##" in generated_text:
#             plot_intent = True
#             generated_text = generated_text.replace("##PLOT##", "").strip()
# 
#         sql_lines = generated_text.split('\n')
#         final_sql = []
#         in_sql_block = False
#         for line in sql_lines:
#             stripped_line_upper = line.strip().upper()
#             if not in_sql_block and any(stripped_line_upper.startswith(kw) for kw in ["SELECT", "INSERT", "UPDATE", "DELETE", "CREATE", "DROP", "ALTER", "WITH", "PRAGMA"]):
#                 in_sql_block = True
#                 final_sql.append(line)
#             elif in_sql_block:
#                 if stripped_line_upper == "" or (not any(char.isalpha() for char in stripped_line_upper) and ';' not in stripped_line_upper):
#                     break
#                 final_sql.append(line)
# 
#         sql_query = "\n".join(final_sql).strip()
# 
#         if sql_query and not sql_query.endswith(';'):
#             last_word = sql_query.split()[-1].upper() if sql_query.split() else ""
#             if not any(last_word.endswith(kw) for kw in ["FROM", "WHERE", "BY", "LIMIT", "ON"]):
#                  sql_query += ';'
# 
#         if plot_intent:
#             sql_query += "##PLOT##"
# 
#         return sql_query
#     except Exception as e:
#         print(f"Error generating or parsing SQL from Gemini: {e}")
#         return "ERROR: Failed to generate or parse SQL query from LLM."
# 
# 
# def execute_sql_query(cursor, sql_query):
#     """Executes an SQL query and returns the results."""
#     try:
#         cursor.execute(sql_query)
#         result = cursor.fetchall()
#         column_names = [description[0] for description in cursor.description] if cursor.description else []
#         return result, column_names
#     except sqlite3.Error as e:
#         print(f"SQL Error: {e}")
#         return None, None
# 
# def format_answer(question: str, result: list, column_names: list, plot_filename=None) -> str:
# 
#     if result is None:
#         return "Issue while querying the database."
#     if not result:
#         return "No relevant data for the asked question. Sorry :("
# 
#     if plot_filename:
#         if len(column_names) >= 2:
#             try:
#                 df_plot = pd.DataFrame(result, columns=column_names)
# 
#                 for col in df_plot.columns:
#                     df_plot[col] = pd.to_numeric(df_plot[col], errors='ignore')
#                     if df_plot[col].dtype == 'object':
#                         try:
#                             df_plot[col] = pd.to_datetime(df_plot[col])
#                         except ValueError:
#                             pass
#                 x_col = column_names[0]
#                 y_col = column_names[1]
# 
#                 plt.figure(figsize=(10, 6))
# 
#                 if pd.api.types.is_numeric_dtype(df_plot[y_col]) and (pd.api.types.is_numeric_dtype(df_plot[x_col]) or pd.api.types.is_datetime64_any_dtype(df_plot[x_col])):
#                     if pd.api.types.is_datetime64_any_dtype(df_plot[x_col]):
#                         df_plot = df_plot.sort_values(by=x_col)
#                         plt.plot(df_plot[x_col], df_plot[y_col], marker='o', linestyle='-')
#                         plt.xticks(rotation=45, ha='right')
#                     else:
#                         if df_plot[x_col].nunique() < 20 and not pd.api.types.is_float_dtype(df_plot[x_col]):
#                             plt.bar(df_plot[x_col].astype(str), df_plot[y_col])
#                             plt.xticks(rotation=45, ha='right')
#                         else:
#                             plt.plot(df_plot[x_col], df_plot[y_col], marker='o', linestyle='-')
#                             plt.xticks(rotation=45, ha='right')
# 
# 
#                     plt.xlabel(x_col.replace('_', ' ').title())
#                     plt.ylabel(y_col.replace('_', ' ').title())
#                     plt.title(f"{y_col.replace('_', ' ').title()} by {x_col.replace('_', ' ').title()} for '{question}'")
#                     plt.grid(True, linestyle='--', alpha=0.7)
#                     plt.tight_layout()
#                     plt.savefig(plot_filename)
#                     plt.close() # Close the figure to free memory
#                     return f"Here is the data for '{question}':\n{pd.DataFrame(result, columns=column_names).to_string(index=False)}\n\nPlot saved as: {plot_filename}"
#                 else:
#                     return f"Here is the data for '{question}':\n{pd.DataFrame(result, columns=column_names).to_string(index=False)}\n\nNote: Could not generate a plot for this data format. Plotting requires at least two columns with suitable numeric or datetime types."
# 
#             except Exception as plot_e:
#                 print(f"Error generating plot: {plot_e}")
#                 return f"Here is the data for '{question}':\n{pd.DataFrame(result, columns=column_names).to_string(index=False)}\n\nNote: Encountered an error while generating the plot: {plot_e}"
#         else:
#             return f"Here is the data for '{question}':\n{pd.DataFrame(result, columns=column_names).to_string(index=False)}\n\nNote: Plotting requires at least two columns of data."
# 
#     if len(result) == 1 and len(result[0]) == 1:
#         value = result[0][0]
#         if isinstance(value, (int, float)):
#             return f"The {question.lower()} is: {value:,.2f}" if 'sales' in question.lower() or 'spend' in question.lower() else f"The {question.lower()} is: {value}"
#         else:
#             return f"The answer to '{question}' is: {value}"
#     else:
#         df_result = pd.DataFrame(result, columns=column_names)
#         return f"Here is the data for '{question}':\n{df_result.to_string(index=False)}"
#     if len(result) == 1 and len(result[0]) == 1:
#         value = result[0][0]
#         if isinstance(value, (int, float)):
#             return f"The {question.lower()} is: {value:,.2f}" if 'sales' in question.lower() or 'spend' in question.lower() else f"The {question.lower()} is: {value}"
#         else:
#             return f"The answer to '{question}' is: {value}"
#     else:
#         df_result = pd.DataFrame(result, columns=column_names)
#         return f"Here is the data for '{question}':\n{df_result.to_string(index=False)}"
# 
# def ask_ai_agent_cli(question: str, gemini_model, cursor) -> str:
#     print(f"\nUser: {question}")
#     print("Fetching schema...")
#     schema = get_table_schema(cursor)
#     print("Schema fetched.")
# 
#     print("Asking LLM for SQL query...")
#     sql_query_with_plot_tag = ask_llm_for_sql(question, schema, gemini_model)
# 
#     plot_requested = False
#     if sql_query_with_plot_tag.endswith("##PLOT##"):
#         plot_requested = True
#         sql_query = sql_query_with_plot_tag[:-len("##PLOT##")]
#     else:
#         sql_query = sql_query_with_plot_tag
# 
#     print(f"Generated SQL: {sql_query}")
#     if plot_requested:
#         print("Plotting requested.")
# 
#     if sql_query.startswith("ERROR:"):
#         return sql_query
# 
#     print("Executing SQL query...")
#     query_result, column_names = execute_sql_query(cursor, sql_query)
#     print("SQL query executed.")
# 
#     print("Formatting answer...")
#     plot_filename = None
#     if plot_requested:
#         plot_filename = "generated_plot.png"
# 
#     human_readable_answer = format_answer(question, query_result, column_names, plot_filename)
#     print("Answer formatted.")
# 
#     return human_readable_answer
# 
# 
# if __name__ == "__main__":
#     db_schema = get_table_schema(cursor)
#     print("\n--- Database Schema ---")
#     for table, cols in db_schema.items():
#         print(f"{table}: {cols}")
#     print("---------------------\n")
# 
#     print("--- AI Agent Command-Line Interface ---")
# 
#     while True:
#         user_question = input("You: ")
#         if user_question.lower().strip() == 'exit':
#             print("AI: Goodbye!")
#             break
# 
#         answer = ask_ai_agent_cli(user_question, gemini_model, cursor)
#         print(f"AI: {answer}\n")
# 
#     conn.close()
#     print("Database connection closed.")